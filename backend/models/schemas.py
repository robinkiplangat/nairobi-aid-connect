from pydantic import BaseModel, Field
from typing import Literal, Optional
from datetime import datetime
import uuid

class Coordinates(BaseModel):
    lat: float
    lng: float

class NewHelpRequest(BaseModel):
    request_id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    timestamp: datetime = Field(default_factory=datetime.utcnow)
    source: Literal["direct_app", "twitter"]
    request_type: Literal["Medical", "Legal", "Shelter"]
    location_text: str
    coordinates: Coordinates
    original_content: str
    status: str = "pending"  # Added status for tracking

class Volunteer(BaseModel):
    volunteer_id: str = Field(default_factory=lambda: str(uuid.uuid4())) # Or use MongoDB's ObjectId if preferred and handle conversion
    name: str
    phone_number: str # Assuming this is used for contact/identification
    skills: list[Literal["Medical", "Legal", "Shelter"]]
    verification_code: Optional[str] = None
    is_verified: bool = False
    status: Literal["available", "busy", "offline"] = "offline"
    last_seen: datetime = Field(default_factory=datetime.utcnow)
    # Storing coordinates directly on volunteer for geospatial queries
    current_location: Optional[Coordinates] = None

class VolunteerStatus(BaseModel):
    volunteer_id: str
    timestamp: datetime = Field(default_factory=datetime.utcnow)
    status: Literal["available", "busy", "offline"]

class MatchAssignment(BaseModel):
    assignment_id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    request_id: str
    volunteer_id: str
    timestamp: datetime = Field(default_factory=datetime.utcnow)
    # Tokens for securing chat session access
    requester_token: str = Field(default_factory=lambda: str(uuid.uuid4()))
    volunteer_token: str = Field(default_factory=lambda: str(uuid.uuid4()))

class ChatSessionEstablished(BaseModel):
    chat_room_id: str
    assignment_id: str
    request_id: str # Added for routing to requester client
    volunteer_id: str # Added for routing to volunteer client
    requester_token: str # To be used by the requester to join the chat
    volunteer_token: str # To be used by the volunteer to join the chat
    timestamp: datetime = Field(default_factory=datetime.utcnow)

# --- API Specific Models ---

class DirectHelpRequestPayload(BaseModel):
    request_type: Literal["Medical", "Legal", "Shelter"]
    coordinates: Optional[Coordinates] = None # User selected lat/lng from map
    location_text: Optional[str] = None # Optional text description of location
    original_content: str # Description of the request, e.g., "Direct app request for Medical aid"
    # Potentially user_id or some form of identification if users are logged in
    # user_id: Optional[str] = None

class VolunteerVerificationPayload(BaseModel):
    verification_code: str
    # volunteer_id: str # Assuming the volunteer is identified by the code

class VolunteerCreatePayload(BaseModel):
    name: str
    phone_number: str
    skills: list[Literal["Medical", "Legal", "Shelter"]]
    # Admin might create volunteer, verification code generated by system

class Resource(BaseModel):
    resource_id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    title: str
    content: str
    category: str # e.g., "Medical Aid", "Legal Advice", "Shelter Locations"
    last_updated: datetime = Field(default_factory=datetime.utcnow)

class Update(BaseModel):
    update_id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    title: str
    summary: str
    full_content: Optional[str] = None
    timestamp: datetime = Field(default_factory=datetime.utcnow)
    source: Optional[str] = None # E.g., "Official", "Community Report"


class MapHotspot(BaseModel):
    """Data structure for representing an active help request on the map."""
    id: str # Typically the request_id
    coordinates: Coordinates # The already obfuscated coordinates
    request_type: Literal["Medical", "Legal", "Shelter"]
    timestamp: datetime # Timestamp of the original request


# Generic response model
class GenericResponse(BaseModel):
    message: str
    success: bool = True
    details: Optional[dict] = None

# MongoDB specific models (can inherit from above or be separate)
# For now, the above models can serve as the structure for MongoDB documents as well.
# If specific MongoDB features like ObjectId are needed, we can adjust.

# Example: If using MongoDB's ObjectId
# from pydantic import Field, BaseModel
# from bson import ObjectId
# class PyObjectId(ObjectId):
#     @classmethod
#     def __get_validators__(cls):
#         yield cls.validate
#     @classmethod
#     def validate(cls, v):
#         if not ObjectId.is_valid(v):
#             raise ValueError("Invalid objectid")
#         return ObjectId(v)
#     @classmethod
#     def __modify_schema__(cls, field_schema):
#         field_schema.update(type="string")

# class MongoVolunteer(Volunteer):
#     id: Optional[PyObjectId] = Field(alias='_id')
#     class Config:
#         json_encoders = { ObjectId: str }
#         arbitrary_types_allowed = True # Allow PyObjectId
#         populate_by_name = True # To allow using '_id' as 'id'
